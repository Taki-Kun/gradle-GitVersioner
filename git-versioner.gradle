/*
 * Copyright (C) 2016 Pascal Welsch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

ext {
    GitVersion version = this.generateVersionName()
    gitVersion = version
    gitVersionName = version.name
}

public class GitVersion {

    public String name;

    public String versionName;

    public String testVersion;

    public int version = 0;

    public String branchName;

    public String shortBranch = "";

    public int branchVersion = 0;

    public int localChanges = 0;

    public String commit;

    @Override
    public String toString() {
        if (name == null || name.isEmpty()) {
            return "${super.toString()}{" +
                    "name='" + name + '\'' +
                    ", version=" + version +
                    ", branchName='" + branchName + '\'' +
                    ", shortBranch='" + shortBranch + '\'' +
                    ", branchVersion=" + branchVersion +
                    '}';
        }
        return name
    }
}

def GitVersion generateVersionName() {

    // check if git project
    def status = 'git status'.execute([], rootDir)
    status.waitFor()
    def isGitProject = status.exitValue()

    if (isGitProject == 69) {
        println("git returned with error 69\n" +
                "If you are a mac user that message is telling you is that you need to open the " +
                "application XCode on your Mac OS X/macOS and since it hasn’t run since the last " +
                "update, you need to accept the new license EULA agreement that’s part of the " +
                "updated XCode.")
    }

    if (isGitProject > 0) {
        println("ERROR: can't generate a git version, this is not a git project")
        println(" -> Not a git repository (or any of the parent directories): .git")
        return new GitVersion()
    }

    // read ext properties
    Map configuration = getPropertyOrDefault(rootProject, "gitVersioner", [:]) as Map
    def String[] stableBranches = configuration.get("stableBranches") ?: []
    def defaultBranch = configuration.get("defaultBranch") ?: "master"
    float yearFactor = (configuration.get("yearFactor") ?: "1000").toString().toFloat()
    boolean snapshotEnabled = configuration.get("snapshotEnabled") != false
    boolean localChangesCountEnabled = configuration.get("localChangesCountEnabled") != false
    def shortNameClosure = configuration.get("shortName")

    // get information from git
    def currentBranch = 'git symbolic-ref --short -q HEAD'.execute([], rootDir).text.trim()

    // use a defined stable branch when on such a branch
    if (stableBranches.contains(currentBranch)) {
        defaultBranch = currentBranch
    }

    def currentCommit = 'git rev-parse HEAD'.execute([], rootDir).text.trim()

    def log = "git log --pretty=format:'%at' --reverse".execute([], rootDir)
            .text.trim().readLines()
    long initialCommitDate = log.size() > 0 ? log.first().trim().replaceAll('\'', '').toLong() : 0
    def localChangesCount = 'git diff-index HEAD'.execute([], rootDir).text.trim().readLines().
            size()
    boolean hasLocalChanges = localChangesCount > 0

    def diffToDefault = "git rev-list --no-merges $defaultBranch..".execute([], rootDir)
    diffToDefault.waitFor()
    if (diffToDefault.exitValue() != 0) {
        diffToDefault = "git rev-list --no-merges origin/$defaultBranch..".execute([], rootDir)
    }
    def featurelines = diffToDefault.text.trim().readLines()
    println("--#featurelines: ${featurelines}")
    def commitsInFeatureBranch = featurelines.size();

    def defaultAndFeatureLines = "git rev-list --no-merges $currentCommit"
            .execute([], rootDir).text.trim().readLines()

    // the sha1 of the latest commit in the default branch
    def lastestDefaultBranchCommitSha1 = defaultAndFeatureLines.size() == 1 ?
            defaultAndFeatureLines.first() : {
        try {
            return defaultAndFeatureLines.findAll { !featurelines.contains(it) }.first()
        } catch (NoSuchElementException e) {
            // no commits found
            return currentCommit
        }
    }()
    println("lastestDefaultBranchCommitSha1: ${lastestDefaultBranchCommitSha1}")

    // get additional information
    def defaultBranchDatesLog = "git log $lastestDefaultBranchCommitSha1 --pretty=format:'%at' -n 1"
            .execute([], rootDir).text.trim().replaceAll('\'', '')
    long latestCommitDate = defaultBranchDatesLog.isLong() ? defaultBranchDatesLog.toLong() :
            initialCommitDate

    // commit count is the first part of the version
    def defautBranchCommitCount = "git rev-list --no-merges $lastestDefaultBranchCommitSha1 --count"
            .execute([], rootDir).text.trim()
    def commitCount = defautBranchCommitCount.isInteger() ? defautBranchCommitCount.toInteger() : 0

    // calculate the time part of the version. 2500 == 2 years, 6 months; 300 == 0.3 year
    def long YEAR_IN_SECONDS = 60 * 60 * 24 * 365
    def diff = latestCommitDate - initialCommitDate

    long time = {
        if (yearFactor <= 0) {
            return 0;
        } else {
            return (diff * yearFactor / YEAR_IN_SECONDS + 0.5).intValue()
        }
    }();
    println("--#commitCount: ${commitCount}")
    println("--#time: ${time}")
    // this is the version
    def combinedVersion = commitCount //+ time
    println("--#combinedVersion: ${combinedVersion}")

    def currentTag = ""
    def mostRecentTag = "git describe --abbrev=0 --tags".execute([], rootDir)
    mostRecentTag.waitFor()
    if (mostRecentTag.exitValue() == 0) {
        currentTag = mostRecentTag.text.trim()
    } else {
        currentTag = "0.0.0"
    }

    def holder = new GitVersion()
    holder.version = combinedVersion
    holder.branchName = currentBranch
    holder.commit = currentCommit
    holder.branchVersion = commitsInFeatureBranch
    holder.localChanges = localChangesCount

    String featureBranchCommits = commitsInFeatureBranch == 0 ? "" : commitsInFeatureBranch.toString()

    // on feature branches, add a branch identifier and the commit count
    def shortBranch = (shortNameClosure ?: {
        if (currentBranch.isEmpty()) {
            return "${currentCommit.subSequence(0, 7)}"
        } else {
            return getTinyBranchName(currentBranch, 2)
        }
    })(holder)
    holder.shortBranch = shortBranch

    def snapshot = {
        def result = ""
        if (featureBranchCommits) {
            result += "-g${shortBranch}"
            result += "[$featureBranchCommits]"
        }
        if (localChangesCountEnabled && localChangesCount > 0) {
            result += "-($localChangesCount)"
        }
        println("--#featureBranchCommits: ${featureBranchCommits}")
        println("--#hasLocalChanges: ${hasLocalChanges}")
        if ((featureBranchCommits || hasLocalChanges) && snapshotEnabled) {
            result += "-SNAPSHOT"
        }
        return result
    }()

    holder.name = "$currentTag$snapshot"
    holder.versionName = "$currentTag".replaceAll('-.*', '').toString()
    holder.testVersion = featureBranchCommits + ("$currentTag".replaceAll('(\\d\\.){2}\\d', '') ? "$currentTag".replaceAll('(\\d\\.){2}\\d', '').toString() : '')
    return holder
}

def Object getPropertyOrDefault(Object root, String name, Object fallback) {
    return root.hasProperty(name) ? root.property(name) : fallback
}

def String getTinyBranchName(String originalName, int length) {
    String nameBase64 = originalName.bytes.encodeBase64().toString()
    if (nameBase64.length() < length) {
        int charPos = originalName.size() % 26 + 65
        String lowerCase = Character.toChars(charPos).toString().toLowerCase()
        return "".padRight(2, lowerCase)
    }

    def outChars = new Integer[length]
    def chars = nameBase64.toCharArray()
    for (int i = 0; chars.size() > i; i++) {
        int c = chars[i]
        int pos = i % length
        if (outChars[pos] == null) {
            outChars[pos] = 0
        }
        int next = (c as int) + outChars[pos]
        outChars[pos] = next % 26
    }

    def result = ""
    for (int i = 0; outChars.size() > i; i++) {
        result += Character.toChars(outChars[i] + 65).toString().toLowerCase()
    }
    return result
}

// git describe --abbrev=0 --tags --always

/*
def String checkoutCommit(String parrentCommit, String childrenCommit) {
    // 子分支相对于父分支新增的提交历史
    def diffToParrentCommit = "git rev-list $parrentCommit..$childrenCommit".execute([], rootDir)
    diffToParrentCommit.waitFor()
    if (diffToParrentCommit.exitValue() != 0) {
        diffToParrentCommit = "git rev-list origin/$parrentCommit..$childrenCommit".execute([], rootDir)
    }

    def featurelines = diffToParrentCommit.text.trim().readLines()

    // 子分支提交历史 = 父分支提交历史 + 子分支新增提交历史
    def parrentAndFeatureLines = "git rev-list $childrenCommit"
            .execute([], rootDir).text.trim().readLines()

    // 子分支筛除新增提交历史 = 父分支部分提交历史，获取关联的父分支提交sha1
    def branchCommitSha1 = parrentAndFeatureLines.size() == 1 ?
            parrentAndFeatureLines.first() : {
        try {
            return parrentAndFeatureLines.findAll { !featurelines.contains(it) }.first()
        } catch (NoSuchElementException e) {
            // no commits found
            return childrenCommit
        }
    }()
}

def String mergeCommit(String parrentCommit, String childrenCommit) {
    childrenCommit = mergeCommit(parrentCommit, childrenCommit)
    // 当前主干分支的父分支的提交历史，release、master
    def parrentLines = "git rev-list origin/$parrentCommit"
            .execute([], rootDir).text.trim().readLines()

    // the sha1 of the latest commit in the default branch
    def branchMergeSha1 = parrentLines.size() == 1 ?
            parrentLines.first() : {
        def tmpcommit = 0
        for (def index = 0; index < aLines.size(); index++) {
            tmpcommit = aLines[index] == tmpcommit ? aLines[index - 1] : tmpcommit
        }
        return tmpcommit
    }()
}
*/
